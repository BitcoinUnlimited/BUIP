
-------

[[File:media/draft.png|40px]]


'''This specification is still in the process of being written.'''

Draft version 0.0.1

-------

<pre>
  BIP: xxxx
  Layer: Peer Services
  Title: Graphene Relay
  Authors: George Bissias <gbiss@cs.umass.edu>, Brian Levine <levine@cs.umass.edu>
  Comments-Summary: 
  Comments-URI: https://github.com/xxxxx
  Status: Draft
  Type: Standards Track
  Created: 2018-07-26
  License: PD
</pre>

==Abstract==


Graphene is a protocol for efficiently relaying blocks across the peer-to-peer network.

==Motivation==

Relaying blocks across the peer-to-peer (P2P) network using the least amount of bandwidth and latency has a number of advantages for the operation of any cryptocurrency. Blocks that can be relayed using less bandwidth propagate more quickly, which can increase synchronization among peers and  reduce forks in the chain. Using less bandwidth to relay a block also allows greater participation by peers who are behind limited-bandwidth links and routes.  Finally, an efficient mechanism for relaying blocks can allow maximum block size to increase, sustaining a larger number of transactions per second overall.  

This specification is a stand-alone description of Graphene, but is based heavily on previous work by Ozisik, Andresen, Bissias, Houmansadr, and Levine [[091.mediawiki#ref1|<nowiki>[1]</nowiki>]]. 

==Specification for Version 1==

===Intended Protocol Flow===

<A id='fig1'>Figure 1:
[[File:media/buip091-messaging.png|10px|A diagram of Graphene's messaging between Node A as the sender and Node B as the receiver.]]</a>

The core idea behind Graphene is for the sender to avoid sending information that is already held by the receiver. Blocks are comprised of a header that is previously unknown to the receiver, and a collection of transactions that are likely to be already within the receiver's mempool. Therefore, to save banwidth, Graphene attempts to not resend the actual transactions nor transaction IDs. Instead, Graphene makes use of two ''set reconciliation'' data structures for expressing the list of transactions: [https://en.wikipedia.org/wiki/Bloom_filter Bloom filters] [[091.mediawiki#ref4|<nowiki>[4]</nowiki>]] and Invertible Bloom Lookup Tables (IBLTs) [[091.mediawiki#ref2|<nowiki>[2</nowiki>]][[091.mediawiki#ref3|<nowiki>,3]</nowiki>]]. The combination of the two data structures is more efficient than using either alone to express the transaction list, and it is more efficient than constructing a list from shortened transaction IDs.

An overview of Graphene is presented in [[091.mediawiki#fig1|Figure 1]], which depicts the following steps between two peers that have confirmed that they are running the same version of the protocol. 

# A sender informs the receiver that a new block is available using an '''inv''' message. 
# If the block is not already known to the receiver, she responds with a '''get_grblk''' message that includes a count of transactions in her mempool, ''m''.
# The sender creates a Bloom filter ''S'' of all transaction IDs in the block along with an IBLT ''I'' containing just the "cheap hash" (the result of the ''GetCheapHash'' method) of each transaction ID. Additionally, any full transactions likely missing from the receiver (such as the coinbase for the block) are collected into additional transactions list ''V''. If there does not exist a protocol-defined canonical transaction ordering, then the sender also creates a list of transaction ranks ''R'', listed lexicographically by ID, which indicates (with ''log(n)'' bits for each ID) the intended order for each transaction ID. The sender assembles ''S'', ''I'', ''V'', ''R'', and the block header into a '''grblk''' message, which he sends to the receiver.   
# The receiver begins by aggregating all locally known transaction IDs into set ''T'', which is comprised of those found in ''V'' (see above) as well as her mempool and orphan pool. She then uses Bloom filter ''S'' to filter transaction IDs from ''T''. Any transaction that appears to be in ''S'' is added to her own IBLT, '' I' ''. She then performs an IBLT ''subtraction operation'' [[091.mediawiki#ref3|<nowiki>[3]</nowiki>]] on  ''I'' and  '' I' '' to decode the set of transaction IDs in the symmetric difference between the two sets. From this subtraction operation, she may learn either the set of false positive IDs ''F'' that falsely passed through ''S'' or the set of IDs ''M'' that are in the block but missing from ''T''.  The subtraction operation either succeeds or fails. There are two types of failure; until later versions of this protocol, recovery from these failures requires a fall-back method:
## Success: The IBLT subtraction succeeds and the set ''M'' is empty. All transactions in the block are possessed by the receiver.
## Success: The IBLT subtraction succeeds and the set ''M'' is non-empty. Missing transactions must be requested. Here the receiver requests the missing transactions using a '''get_grblktx''' message, to which the receiver responds with a '''grblktx''' message containing the full transactions indicated by ''M''. 
## IBLT Decode failure:  The IBLT subtraction operation fails entirely. In this case the receiver cannot be certain of the complete set of transaction IDs in the block. This failure occurs when the receiver does not possess many transactions in the block. Until later versions of this protocol, she must request a fail-over block such as XThin or a full block. 
## IBLT Checksum failure, detected by Merkle Root comparison: IBLT subtraction succeeds, but returns an erroneous transaction ID due to faulty IBLT checksum. In this (unlikely) scenario, the receiver will issue a '''get_grblktx''' message for the erroneous transaction ID, for which the sender will not return no transaction not return no. This will ultimately lead to an invalid Merkle root for the receiver, which will result in a fail-over block being requested (e.g., a full or XThin block).
# If IBLT subtraction succeeds (and missing transactions are received), and if no checksum error occurs, then the receiver will be left with an unordered set of transactions that are in the block. (Note that at this stage the receiver is certain to have the actual transactions, not just their IDs). 
# The receiver places the transactions in a Merkle tree, which is validated against the root stated in the block header. The order of transactions in the Merkle tree is either determined by the network's protocol-defined canonical ordering or by the specific rank information ''R'' included in '''grblk'''. 

Below, we state how the sender should jointly optimize the parameters for Bloom filter ''S'' and IBLT ''I'' so that minimal bandwidth is used. First, we provide intuition behind Graphene's design. Subsequently, we detail new messages as well the new data structures contained in those messages. 

====Intuition====

The intuition behind Graphene's use of Bloom filters and IBLTs is as follows, presented as optional reading. 

Let's consider several options for relaying a block. The first option is to simply list each 32-byte transaction ID.  If our block contains ''n=2000'' transactions, then the total cost is 64,000 bytes. Next, we realize that the chances of a accidential collision among 32-bytes IDs is almost nil, and so our second option is to limit each transaction ID to its first 8 bytes. If our block contains ''n=2000'' transactions, then the total cost is already down to 16,000 bytes. 

Our third option is to use Bloom filters, which are an incredibly useful probabilistic data structure for determining whether ''items'' are members of a given  ''set''. In this case, our set is all transactions in the sender's block (actually, the set of transaction IDs); and the items are the transactions IDs in the receiver's mempool. A Bloom filter has two special characteristics. First, it has no ''false negatives''. That is, if a Bloom filter tells us that a transaction ID ''is not'' in the set, then it ''definitely is not'' in the set.  Second, a Bloom filters does have ''false positives''. That is, if a Bloom filter tells us that a transaction ID ''is'' in the set, then it ''might not be'' in the set. We can set the Bloom filter's false positive rate (FPR) to whatever we like. There is an important trade-off though: if the FPR is low, and the Bloom filter is therefore accurate, then it will also be larger in terms of bytes. If we don't mind some wrong answers about what transaction IDs are in the block, then the Bloom filter will be smaller. 

How much space is it to relay blocks using Bloom filters? For example, we could set the FPR of the Bloom Filter to ''f=1/m''. In that case, when the receiver checks each of the ''m'' transaction IDs in her mempoool, we can expect that the Bloom filter will wrongly state that ''f*m=(1/m)*m=1'' transaction is in the block on average. To make matters worse, we won't know which transaction is the wrong one; as a result of the extra transaction, the Merkle root won't validate. We can try to fix this problem by lowering the FPR of the filter. For example, if we set the FPR to ''f=1/(144m)'', then we can expect that the filter will permit a wrong answer only about once every 144 blocks relayed (i.e., only about once a day). But keep in mind, this accuracy will cost us in bytes. The size of a Bloom filter with ''n'' items inserted and a false positive rate of ''f=1/144m'' [https://en.wikipedia.org/wiki/Bloom_filter#Optimal_number_of_hash_functions is well known to be] 
''-n*ln(f)/ln<sup>2</sup>(2) = n*ln(1/(144m))/(8ln<sup>2</sup>(2))'' bytes. For example, for a block with ''n=2000'' transactions and a mempool of ''m=6000'' transactions total, the Bloom filter will be about 7,113 bytes. That's an improvement over our first and second options, but we can do better. 

A fourth option is presented by Invertible Bloom Lookup Tables (IBLTs) [[091.mediawiki#ref2|<nowiki>[2]</nowiki>]], another useful probabilistic data structure. They are designed to allow us to discover the [https://en.wikipedia.org/wiki/Symmetric_difference symmetric difference] between two sets of items. For example, we can create an IBLT of all transactions IDs that are in the sender's block, and then create another IBLT of the transactions in the receiver's mempool. A ''subtraction'' [[091.mediawiki#ref3|<nowiki>[3]</nowiki>]] of the first IBLT from the second will tell us exactly which transactions in the mempool are not in the block. Given this functionality, one can use IBLTs alone [[091.mediawiki#ref7|<nowiki>[7]</nowiki>]] to relay the block from sender to receiver, but unfortunately it is not an efficient approach. The size in bytes of an IBLT increases linearly with the size of the symmetric difference recovered from it. An IBLT uses about 12 bytes per transaction ID that is part of the symmetric difference, and the overhead of an IBLT (in bytes) is about 140%. And so if the mempool is 2000 transactions larger than the block (i.e., the symmetric difference is 2000), then the sender's IBLT will be about ''(1.4*2000)*12=33,840'' bytes. Not our best option so far.

Our fifth and best solution is a combination of both data structures. First, we pass all transactions in the receiver's mempool through a Bloom filter of the sender's block; however, we allow a good number of false positives, which results in a small Bloom filter. We clean up any mistakes made by the Bloom filter with an IBLT also sent by the sender. The symmetric difference is now quite small: it's equal to number of false positives that were produced by our Bloom filter. There is a trade-off: we can make the Bloom filter larger (more accurate), which results in a smaller IBLT; or we can make the IBLT larger (able to correct more mistakes), which results in a smaller Bloom filter. Graphene picks the parameters of both data structures together so that the summed size is optimally small. For example, for ''n=2000'' and ''m=6000'', a sender computes that an IBLT that can recover ''a=27'' items and a Bloom filter of ''n'' items with a FPR of ''f=0.00675'' is minimal. In our test implementation, this results in 3,316-byte total based on a 715-byte IBLT and a 2601-byte Bloom filter, which is about 1/5 the size of sending 8-bytes per transaction. If a canonical transaction order is not defined, an expression of the transaction ordering must also be sent, which increases the total by 2,750 bytes to 6,066 bytes (i.e., 38% of the cost of sending 8-bytes per transaction). The IBLT will fail to decode about once every 240 blocks.

Graphene maintains this size advantage as block size grows. For example, for a block of ''n=10,000'' transactions, listing 8-bytes of each transaction ID would be 80,000 bytes. With a mempool of ''m=30,000'' transactions, Graphene's cost is 14,482 bytes (or 31,091 bytes without a canonical transaction ordering).


===New Messages===
Graphene introduces four new messages to the network protocol: '''get_grblk''', '''grblk''', '''get_grblktx''', and '''grblktx'''.

====get_grblk====
The '''get_grblk''' message (suggested implementation name: '''GET_GRAPHENE''') transmits a single serialized '''CMempoolInfo''' data structure. It is used to both signal the desire to receive a graphene block and to communicate the number of transactions in the receiver's mempool. 

====grblk====
The '''grblk''' message (suggested implementation name: '''GRAPHENEBLOCK''') transmits a single serialized '''CGrapheneBlock''' data structure. In the absence of failure or after successful recovery of items from set ''M'' (see above), the message contains sufficient information for the receiver to reconstruct the full block.

====get_grblktx====
The '''get_grblktx''' (suggested implementation name: '''GET_GRAPHENETX''') message transmits a single serialized '''CRequestGrapheneBlockTx'''. This message is sent in the event that the IBLT subtraction operation succeeded and revealed a non-empty set of missing transaction IDs ''M'' (see figure below).

====grblktx====
The '''grblktx''' (suggested implementation name: '''GRAPHENETX''') message transmits a single serialized '''CGrapheneBlockTx'''. This message is sent in response to '''get_grblktx''' (see figure below); it contains full transactions corresponding to any cheap hashes in '''CRequestGrapheneBlockTx''' that also appear in the block.

[[File:media/buip091-missing.png|10px|alt=A diagram of a receiver requesting missing transactions.|A diagram of a receiver requesting missing transactions]]

===New data structures===
Graphene introduces several new data structures to the network protocol: '''CMemPoolInfo''', '''CGrapheneBlock''', '''CIblt''' '''CGrapheneBlockTx''', and '''CRequestGrapheneBlockTx'''.

All data structures use the standard bitcoin serialization format. And except for '''CGrapheneBlock''', the data structures are comprised of relatively simple c++ constructs, which we detail below. '''CGrapheneBlock''' contains '''CGrapheneSet''', which itself contains Bloom filter and IBLT data structures, denoted '''CBloomFilter''' and '''CIblt''', respectively.
We describe each of these complex structures separately.

====CGrapheneBlock====
''CGrapheneBlock'' is the fundamental data structure for graphene block propagation. Assuming no unrecoverable failures arise, and combined with any missing transactions recovered from the sender, this data structure contains all information necessary to reconstruct the full block. It is sent as part of the '''grblk''' message.

{|
 |'''Field Name'''||'''Type'''||'''Size'''||'''Purpose'''
 |-
 |header||Block header||80 bytes||The header of the block being provided
 |-
 |vAdditionalTxs||<nowiki>vector<CTransaction></nowiki>||variable||Transactions that the receiver is probably missing
 |-
 |nBlockTxs||uint64_t||8 bytes||Number of Transactions in the block
 |-
 |grapheneSet||CGrapheneSet||variable||Encapsulates Graphene set reconciliation logic
 |}

The vAdditionalTxs field should include at least the coinbase transaction, since it is not possible for it to be in the receiver's mempool.

====CGrapheneSet====
''CGrapheneSet'' contains all information critical to the graphene set reconciliation process, absent any block-specific details. It is the only non-standard data structure in ''CGrapheneBlock''.

{|
 |'''Field Name'''||'''Type'''||'''Size'''||'''Purpose'''
 |-
 |ordered||bool||1 byte||True if order is important in the set
 |-
 |nReceiverUniverseItems||uint64_t||8 bytes||The number of transactions in the receiver's mempool
 |-
 |encodedRank||<nowiki>vector<unsigned char></nowiki>||ordered * ceil(n log(n))/8 bytes||Order information for items in set
 |-
 |setFilter||CBloomFilter||variable||Bloom filter containing items in set
 |-
 |setIblt||CIblt||variable||IBLT containing items in set
 |}

====CBloomFilter====
''CBloomFilter'' is an implementation of a standard Bloom filter. It is used as part of the set reconciliation process in ''CGrapheneSet'' to filter out transactions from ''T'' that do not belong to the block.

{|
 |'''Field Name'''||'''Type'''||'''Size'''||'''Purpose'''
 |-
 |vData||<nowiki>vector<unsigned char></nowiki>||variable||Bit array for filter
 |-
 |isFull||bool||1 byte||True if every bit in vData is set to 1
 |-
 |isEmpty||bool||1 byte||True if every bit in vData is set to 0
 |-
 |nHashFuncs||unsigned int||2, 4 bytes||Number of hash functions used in filter
 |-
 |nTweak||unsigned int||2, 4, bytes||Additive offset for hash function inputs
 |-
 |nFlags||unsigned char||1 byte||Defines behavior for transaction insertion
 |}

====CIblt====
''CIblt'' is an IBLT implementation that is part of the ''CGrapheneSet'' reconciliation process. In the absence of a reconciliation failure, ''CIblt'' will generate false positive list ''F'' and missing transition cheap hashes ''M''.

{|
 |'''Field Name'''||'''Type'''||'''Size'''||'''Purpose'''
 |-
 |version||uint64_t||8 bytes||Version bits
 |-
 |n_hash||uint8_t||1 byte||Number of hash functions used
 |-
 |is_modified||bool||1 byte||True if any items have been inserted into the IBLT
 |-
 |hashTable||<nowiki>vector<HashTableEntry></nowiki>||variable||Data cells for IBLT
 |}

The Graphene protocol requires that IBLT '' I' '', created by the receiver, be subtracted from IBLT ''I'', originating from the sender. In order for this operation to succeed, it is critical that the IBLTs use the same quantity of hash functions, have the same number of cells, and that hash function ''i'' uses the same function and seed for both ''I'' and '' I' ''. Although the sender may use [https://github.com/umass-forensics/IBLT-optimization complex optimization techniques] to determine the number of cells and hash functions for ''I'', the receiver should simply copy those values provided that they are reasonably sized. The ''i''th hash function is the [http://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp MurmurHash3] with seed ''i''.

====HashTableEntry====
''HashTableEntry'' implements a single cell of the ''CIblt'' data structure.

{|
 |'''Field Name'''||'''Type'''||'''Size'''||'''Purpose'''
 |-
 |count||uint32_t||4 bytes||Number of items
 |-
 |keySum||uint64_t||8 bytes||XOR of all keys
 |-
 |keyCheck||uint32_t||4 bytes||Error checking for keySum
 |-
 |valueSum||vector<nowiki><uint8_t></nowiki>||variable||XOR of all values
 |}

====CMemPoolInfo====
''CMemPoolInfo'' provides a count of transactions in the receiver's mempool and corresponds to the variable ''m'' in the description above. It is sent as part of the '''get_grblk''' message.

{|
 |'''Field Name'''||'''Type'''||'''Size'''||'''Purpose'''
 |-
 |nTx||uint64_t||8 bytes||Number of transactions in the receiver's mempool
 |}
 
 
====CRequestGrapheneBlockTx====
''CRequestGrapheneBlockTx'' is used by the receiver to request missing transactions ''M'' according to their cheap hashes. It is sent as part of the '''get_grblktx''' message.

{|
 |'''Field Name'''||'''Type'''||'''Size'''||'''Purpose'''
 |-
 |blockhash||uint256||32 bytes||The hash of the block corresponding to missing transactions
 |-
 |setCheapHashesToRequest||<nowiki>set<uint64_t></nowiki>||variable||Cheap hashes of missing transactions requested by receiver
 |}

====CGrapheneBlockTx====
''CGrapheneBlockTx'' is returned as part of the '''grblktx''' message. It contains full transactions corresponding to the cheap hashes included in ''CRequestGrapheneBlockTx'' and is returned by the sender in response to a '''get_grblktx''' message.

{|
 |'''Field Name'''||'''Type'''||'''Size'''||'''Purpose'''
 |-
 |blockhash||uint256||32 bytes||The hash of the block corresponding to missing transactions
 |-
 |vMissingTx||<nowiki>vector<CTransaction></nowiki>||variable||Missing transactions requested by receiver
 |}


==Protocol Versioning==
Graphene protocol version will be communicated using the existing VERSION message as specified [https://bitcoin.org/en/developer-reference#version Bitcoin Developer Reference]. The existing message will be augmented as follows.
# A new <code>serviceMap</code> field will be added that contains version information for various network services. 
# <code>serviceMap</code> is of type <nowiki>vector<pair<std::string, uint64_t>></nowiki>.
# Graphene-enabled nodes will add the entry "graphene":version_bits to <code>serviceMap</code> where <code>version_bits</code> indicate the latest supported version of Graphene.

Contrary to the serialization format for new data structures, serialization for the version field is encoded using the compactsize encoding.

===Sample Version Implementation===

==Implementation Notes==
It is possible to maliciously construct an IBLT that will cause a simplistic IBLT implementation to loop forever while decoding. The IBLT implementation used must have a limit on the number of iterations that a given instance of an IBLT can be "peeled" before failure. 

==Recovery==
Graphene uses IBLTs, which are a probabilistic data structure that has a tunable but non-zero failure rate during normal operation. The IBLT used in Graphene should be tuned to fail once every 240 blocks relayed or fewer for all sizes of IBLT used. 

Upon failure, a fallback option must be used. Currently, the only option is to fall back to an XTreme Thin (XThin) Block. Future versions of this specification will specify a more efficient in-protocol recovery mechanism . 

===Selecting parameters for the Bloom Filter and IBLT===
Graphene is efficient when the parameters of the Bloom Filter and IBLT are set correctly by the sender. Here we present two methods of setting these parameters. Any method for parameterizing the Bloom Filter and IBLT can be selected by the sender, but it must be more efficient than simply sending the shortened transaction IDs. The first method is simpler to implement, but it also less efficient and will result in a slightly lower decode rate than desired.

1. Let ''m'' be the size of the receiver's mempool, and let ''n'' be the number of transactions in the block. Let ''t'' be the average size in bytes per item required  to recover ''a'' items from it (i.e., total IBLT table size in bytes divided by ''a''). For example, in our implementation, t=15 bytes approximately. Then the IBLT should be parameterized to recover ''a=n/(ct)'' items, where ''c=8ln<sup>2</sup>(2)''.  The Bloom filter should be set to have a false positive rate (FPR) of ''f=a/(m-n)''. The derivation of these values is presented in the Appendix of this specification. 

2. The sizes of the Bloom filter sand IBLTs can be significantly smaller if a (brute force) linear search is used to parameterize the two data structures.  Simply put, for each integer value of ''a'' from 1 to m: (1)  determine  the  size of the IBLT from its actual implementation, taking into account serialization costs; (2) determine the size in bytes of the Bloom filter for a false positive rate of ''f=a/(m-n)'' when ''n'' items  are inserted from its implementation. The value of ''a'' that has the minimum sum cost in bytes is selected. 

We also note that the IBLT itself should also be parameterized to be as small as possible given a desired decode rate and the number of items that will be recovered from it after subtraction with the receiver's IBLT. We have released a stand-alone implementation of [https://github.com/umass-forensics/IBLT-optimization IBLTs in C++] (with a Python wrapper) and a script to determine such values given a stated decode rate. 


====Protocol design====
A simple comparison of Graphene to related work is as follows. A block holds ''n=2000'' transactions, which the receiver holds in its mempool along with 4000 other transactions; in other words ''m=2000+4000=6000''.

Using Graphene, the sender sends an INV, and the receiver responds with a GETDATA and the value of ''m''. The sender computes that an IBLT that can recover ''a=27'' items and a Bloom filter of ''n'' items with a FPR of ''f=a/(m-n)=27/(6000-2000)=0.00675'' is minimal. In our test implementation, this results in 3,316 byte total based a 715-byte IBLT and a 2601-byte Bloom filter. Without a canonical transaction order, an expression of the transaction ordering must also be sent, increasing the total by 2,750 bytes to 6,066 bytes. (The receiver's IBLT is not sent over the network.)  

XTreme Thin Blocks <nowiki>[5]</nowiki> has the receiver start by sending a 3956-byte Bloom Filter of the mempool with an FPR of ''f=1/m=1/2000=0.0005'', and 8-bytes for each of the ''n=2000'' transactions. The total is therefore 3956+8*2000= 19,956.

Compact Blocks <nowiki>[6]</nowiki> would send over just the 8-bytes for each of the ''n=2000'' transactions, for a total of 8*2000= 16,000.

The size of all these approaches grows linearly with block size, but Graphene grows more slowly. As the example shows, Graphene would benefit significantly from a standardized, canonical ordering of transactions in blocks, which has been proposed by others for separate benefits.

====Short transaction ID calculation====
An 8-byte (64-bit) transaction ID results in a very low probability of collision. Let ''b'' be the size in bits of the shortened transaction IDs. The probability of collision in this "Birthday Attack" scenario is well-known to be approximated by ''1-exp(-m(m-1)/2**(b+1))''. For example, for a mempool of ''m=10,000,000'' transactions, the probability of collision using ''b=64'' bits is approximately 0.00000271050. 

==Backward compatibility==
Older clients remain fully compatible and interoperable after this change.

==Implementation==

https://github.com/

==Future Improvements==

Graphene makes the assumption that the mempool of the receiver already contains the transactions in the block. To aid this assumption, future versions of this specification will ask the sender to do the following between Steps 2 and 3.  For each transaction in the block, the sender determines if, for this receiver, he has previously sent or received an INV message. For any transactions where that is not the case, an INV is sent to the receiver.  (The receiver does not need to possess the full transactions before the sender continues with the next step.)


==References==
<a id='ref1'><a id='ref1'><nowiki>[1]</nowiki> OZISIK, A. P. , ANDRESEN G., BISSIAS G., HOUMANSADR A. , and LEVINE, B. N. Graphene: A New Protocol for Block Propagation Using Set Reconciliation. In Proc. of International Workshop on Cryptocurrencies and Blockchain Technology (ESORICS Workshop), (Sept 2017).</a>

<a id='ref2'><nowiki>[2]</nowiki> GOODRICH, M., AND MITZENMACHER, M. Invertible bloom lookup tables. In Conf. on Communications, Control, and Computing (Sept 2011), pp. 792–799.</a>

<a id='ref3'><nowiki>[3]</nowiki> EPPSTEIN, D., GOODRICH, M. T., UYEDA, F., AND VARGHESE, G. What’s the Difference?: Efficient Set Reconciliation Without Prior Context. In Proc. ACM SIGCOMM (2011).</a>

<a id='ref4'><nowiki>[4]</nowiki> BLOOM, B. H. Space/Time Trade-offs in Hash Coding with Allowable Errors. Communications of the ACM 13, 7 (July 1970), 422–426. https://dl.acm.org/citation.cfm?id=362692</a>

<a id='ref5'><nowiki>[5]</nowiki> TSCHIPPER, P. BUIP 010 Xtreme Thinblocks. https://bitco.in/forum/threads/buip010-passed-xtreme-thinblocks.774/, Jan 2016.</a>

<a id='ref6'><nowiki>[6]</nowiki> CORALLO, M. BIP 152: Compact block relay. https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki, April 2016.</a>

<a id='ref7'><nowiki>[7]</nowiki> ANDRESEN, G. O(1) Block Propagation. 
https://gist.github.com/gavinandresen/e20c3b5a1d4b97f79ac2/, August 2014. </a>


==Appendix==

The values for the simple (but less efficient) method of minimizing Graphene's Bloom filter and IBLT are derived as follows. First, the [https://en.wikipedia.org/wiki/Bloom_filter#Optimal_number_of_hash_functions size of a Bloom filter] in bytes, ''T<sub>BF</sub>'', with false positive rate ''f'' and ''n'' items inserted is 

''T<sub>BF</sub> = -n ln(f) / (8 ln<sup>2</sup>(2))'' bytes.  

Let ''T<sub>I</sub>'' be the size of the IBLT. If each item inserted is based on an 8-byte txn ID and 3-byte checksum, and it's typical that the size of the IBLT in bytes follows this relationship:

''T<sub>I</sub> = (1.4a+20) * (8+3) =15.4a+220'' bytes.

Therefore, if we set ''f= a / (m-n)'', then total size of the Bloom filter and IBLT is 

''T = T<sub>BF</sub> T<sub>I</sub> = -n ln(a/(m-n))/(8ln<sup>2</sup>(2)) + 15.4a + 220''. 

Taking the derivative of this equation with respect to ''a'', setting it to 0, and solving it for ''a'', we see that ''T'' is minimized when 

''a=n/(8ln<sup>2</sup>(2)*15.4)''.


==Acknowledgments==

We are grateful for insightful feedback from Andrew Stone, Andrea Suisani, Awemany, and Peter Rizun.

==Copyright==

This document is placed in the public domain.

